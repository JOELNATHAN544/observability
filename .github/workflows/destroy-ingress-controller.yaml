# This workflow handles safe removal of ingress-controller from Kubernetes clusters
# - Multi-cloud support (GKE, EKS, AKS)
# - Requires explicit confirmation to prevent accidental destruction
# - Accesses remote state to properly destroy tracked resources
# - Verifies complete cleanup after destruction
name: Destroy ingress-controller

on:
  # Manual-only trigger for safety
  # Requires user to explicitly choose cloud provider and confirm destruction
  workflow_dispatch:
    inputs:
      cloud_provider:
        description: 'Cloud Provider'
        required: true
        type: choice
        options:
          - gke
          - eks
          - aks
        default: 'gke'
      confirm_destroy:
        description: 'Type "DESTROY" to confirm'
        required: true
        type: string
  # Push trigger for testing branch (workflow registration only, destruction requires manual trigger)
  push:
    branches:
      - feat/issue-28-setup-pipelines-cert-manager-ingress
    paths:
      - '.github/workflows/destroy-ingress-controller.yaml'

# Global environment variables
env:
  TERRAFORM_VERSION: '1.6.0'
  KUBECTL_VERSION: '1.28.0'
  WORKING_DIR: 'ingress-controller/terraform'

jobs:
  # Job 1: Safety validation
  # Prevents accidental destruction by requiring exact confirmation string
  # Only runs on manual workflow_dispatch events (not on push)
  validate-confirmation:
    name: Validate Destroy Confirmation
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      # Verify user typed "DESTROY" exactly (case-sensitive)
      # Workflow fails immediately if confirmation doesn't match
      - name: Check confirmation input
        run: |
          if [ "${{ inputs.confirm_destroy }}" != "DESTROY" ]; then
            echo "‚ùå Destroy confirmation failed. You must type 'DESTROY' to proceed."
            exit 1
          fi
          echo "‚úÖ Destroy confirmation validated"

  # Job 2: Execute destruction
  # Runs only after successful confirmation validation
  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    needs: validate-confirmation
    environment:
      name: production  # Requires GitHub environment approval for additional safety
    
    steps:
      # Fetch repository code containing Terraform configurations
      - name: Checkout code
        uses: actions/checkout@v4

      # Install Terraform CLI for infrastructure destruction
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # Authenticate to Google Cloud (GKE only)
      # Required for: cluster access, state storage (GCS), resource deletion
      - name: Setup Cloud Credentials - GKE
        if: inputs.cloud_provider == 'gke'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      # Install gcloud CLI for GKE operations
      - name: Setup Compute Environment - GKE
        if: inputs.cloud_provider == 'gke'
        uses: google-github-actions/setup-gcloud@v2

      # Authenticate to AWS (EKS only)
      # Required for: cluster access, state storage (S3), resource deletion
      - name: Setup Cloud Credentials - EKS
        if: inputs.cloud_provider == 'eks'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Authenticate to Azure (AKS only)
      # Required for: cluster access, state storage (Blob), resource deletion
      - name: Setup Cloud Credentials - AKS
        if: inputs.cloud_provider == 'aks'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Install kubectl and configure cluster access based on cloud provider
      # Required to verify cleanup after Terraform destruction
      - name: Setup kubectl
        run: |
          # Download and install kubectl
          curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Configure cluster credentials based on cloud provider
          if [ "${{ inputs.cloud_provider }}" == "gke" ]; then
            gcloud container clusters get-credentials ${{ secrets.CLUSTER_NAME }} \
              --region=${{ secrets.CLUSTER_LOCATION }} \
              --project=${{ secrets.GCP_PROJECT_ID }}
          elif [ "${{ inputs.cloud_provider }}" == "eks" ]; then
            aws eks update-kubeconfig \
              --name ${{ secrets.CLUSTER_NAME }} \
              --region ${{ secrets.AWS_REGION }}
          elif [ "${{ inputs.cloud_provider }}" == "aks" ]; then
            az aks get-credentials \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.CLUSTER_NAME }} \
              --overwrite-existing
          fi

      # Remove stale local backend configuration files
      # IMPORTANT: This only removes LOCAL config files, NOT remote state files
      # State files persist in cloud storage (GCS/S3/Blob) and are used for destruction
      - name: Cleanup old backend configs
        working-directory: ${{ env.WORKING_DIR }}
        run: rm -f backend.tf backend-config.tf

      # Generate fresh backend configuration to access remote state
      # State file location: <bucket>/terraform/ingress-controller/terraform.tfstate
      # Terraform needs this state to know which resources to destroy
      - name: Configure backend
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          bash ../../.github/scripts/configure-backend.sh "${{ inputs.cloud_provider }}" "ingress-controller"
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          AZURE_STORAGE_CONTAINER: ${{ secrets.AZURE_STORAGE_CONTAINER }}

      # Initialize Terraform with backend configuration
      # Downloads providers and connects to remote state storage
      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init

      # Create Terraform variables file matching deployment configuration
      # Must match original deployment settings for proper resource identification
      - name: Create terraform.tfvars
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          cat > terraform.tfvars <<EOF
          cloud_provider        = "${{ inputs.cloud_provider }}"
          install_nginx_ingress = true
          release_name          = "nginx-monitoring"
          nginx_ingress_version = "4.14.2"
          namespace             = "ingress-nginx"
          ingress_class_name    = "nginx"
          replica_count         = 2
          EOF

      # Execute Terraform destroy to remove all ingress-controller resources
      # Uses remote state to identify resources and destroy them
      # -auto-approve: Skip manual confirmation (already validated above)
      - name: Terraform Destroy
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform destroy -auto-approve

      # Verify complete resource removal from cluster
      # Checks that ingress-controller namespace and resources are gone
      - name: Verify cleanup
        run: |
          echo "üìä Checking remaining ingress-controller resources..."
          kubectl get namespace ingress-nginx 2>/dev/null || echo "‚úì Namespace removed"
          kubectl get ingressclass nginx 2>/dev/null || echo "‚úì IngressClass removed"
          echo "‚úÖ Destroy complete"
